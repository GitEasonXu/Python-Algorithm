# 设计模式

## 1 定义

设计模式：对软件设计中普遍存在的各种问题，所提出的解决方案。每一个设计模式系统地命名、解释和评价了面向对象系统中一个重要的和重复出现的设计。

- 因此软件设计中问题的定义很重要，有了问题定义后找到对应的解决方案即可。
- 设计模式解决的是面向对象系统中的设计。

面向对象的三大特性：

- 封装
- 继承
- 多态

接口：若干抽象方法的集合，它的作用限制实现接口的类必须按照接口给定的调用方式实现这些方法，对高层模块隐藏了类的内部实现。

接口定义了方法(模板), 子类完成实现, 保证了一致性。

面向对象设计SOLID原则

- 开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

- 里氏替换原则：所有引用父类的地方必须能透明的使用其子类的对象。举例：User父类，VIPUser是子类，一个函数接收User可以正常运行，那么接受VIPUser也应该能正常运行。

- 依赖倒置原则：高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。换言之，要针对接口编程，而不是针对实现编程。

  高层模块不应该依赖底层模块：因为如果底层模块修改了，那么高层也就相应的需要修改。

  二者都应该依赖其抽象：接口是抽象的，高层模块按照接口定义实现业务逻辑调用，底层模块按照接口实现过程。

- 接口隔离原则：使用多个专用的接口，而不使用单一的总接口，即子类不应该依赖那些它不需要的接口。子类直接继承总接口，但是子类没有必要实现总接口的一些方法，那么此时需要对总接口进行拆分。

- 单一职责原则：不要存在多于一个导致类变更的原因。通俗说就是一个类只负责一项职责。

设计模式分类：

- 创建型模式：工厂方法模式、抽象工厂模式、创建者模式、原型模式、单例模式。
- 结构型模式：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式。
- 行为型模式：解释器模式、责任链模式、命令模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、访问者模式、模板方法模式。

## 2.创建型模式

### 2.1简单工厂模式

定义：不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例。

角色：

- 工厂角色(Creator)：
- 抽象产品角色(Product):
- 具体产品角色(Concrete Product):

优点：

- 隐藏了对象创建的实现细节
- 客户端不需要修改代码

缺点：

- 违反了单一职责原则，将创建逻辑写到了一个工厂类里。
- 当添加新产品时，需要修改工厂类代码，违反了开闭原则。重点：增加新的产品时，需要在工厂类里将新产品类的实例化包含进去。

### 2.2工厂方法模式

定义：定义一个用于创建对象的接口(工厂接口)，让子类决定实例化哪些一个产品类。

角色：

- 抽象工厂角色(Creator)：工厂接口
- 具体工厂角色(Concrete Creator): 根据工厂接口，实现不同的工厂角色，不同的工厂角色用于生产不同类的实例化
- 抽象产品角色(Product):类的抽象接口
- 具体产品角色(Concrete Product):类的实现

优点：

- 每个具体产品都对应一个具体工厂类，不需要修改工厂类代码。
- 隐藏了对象创建的实现细节。

缺点：

- 每增加一个具体产品类，就必须增加一个相应的具体工厂类。

### 2.3抽象工厂模式

定义：定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖的对象，相比工厂方法模式，抽象工厂模式中的每个具体工厂都生产一套产品。

例如：生产一部手机，需要手机壳、CPU、操作系统三类对象，其中每类对象都有不同的种类。对每个具体工厂，分别生产一部手机所需要的三个对象。

角色：

- 抽象工厂角色(Creator)：
- 具体工厂角色(Concrete Creator):
- 抽象产品角色(Product)：
- 具体产品角色(Concrete Product)：
- 客户端

优点：

- 将客户端与类的具体实现相分离
- 每个工厂创建了一个完整的产品系列，使得易于交换产品系列
- 有利于产品的一致性（即产品之间的约束关系）

缺点：

- 难以支持新种类的(抽象)产品

### 2.4建造者模式

定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

角色：

- 抽象建造者(Builder):
- 具体建造者(Concrete Builder):
- 指挥者(Director):
- 产品(Product):

建造者模式与抽象工厂模式相似，也用来创建复杂对象。主要区别是建造者模式着重一步步构造一个复杂对象，而抽象工厂模式着重于多个系列的产品对象。

优点：

- 隐藏了一个产品的内部结构和装配过程
- 将构造代码与表示代码分开
- 可以对构造过程进行更精细的控制

### 2.5单例模式

定义：保证一个类只有一个实例，并提供一个访问它的全局访问点。

角色：

- 单例(Singleton)

优点：

- 对唯一实例的受控访问，意思就是只有一个实例
- 单例相当于全局变量，但防止了命名空间被污染。如果使用一个全局变量的话，则变量名称需要注意不被覆盖，但是使用单例则不用怕。

### 2.6创建型模式小结

- 抽象工厂模式和建造者模式相比于简单工厂模式和工厂方法模式而言更灵活也更复杂。
- 通常情况下、设计以简单工厂模式或工厂方法模式开始，当你发现设计需要更大的灵活性时，则像更复杂的设计模式演化。



## 3.结构型模式

### 3.1适配器模式

定义：将一个类的接口转换成客户希望的另一种接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

两种实现方式：

- 类适配器：使用多继承
- 对象适配器：使用组合，B类中实例化A类的对象

角色：

- 目标接口(Target)：A系统中定义的接口
- 待适配的类(Adaptee)：B系统中定义的类
- 适配器(Adapter)：待适配器继承目标接口，然后将B系统定义的类变为成员属性调用。

适用场景：

- 想使用一个已经存在的类，而它的接口不符合你的要求
- 当不想对每一个类都进行子类化匹配它们的接口时，可以使用对象适配器。

### 3.2桥模式

定义：将一个事物的两个维度分离，使其都可以独立的变化。

角色：

- 抽象(Abstraction)：Shape和Color的接口定义
- 细化抽象(Refined Abstraction):抽象子类：直线、红色
- 实现者(Implementor)：
- 具体实现者(Concrete Implementor)

应用场景：

- 当事物有两个维度上的表现，两个维度都可能扩展时。

优点：

- 抽象和实现相分离
- 优秀的扩展能力

### 3.3组合模式

定义：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性

角色：

- 抽象组件(Component):接口
- 叶子组件(Leaf):最小的组件
- 复合组件(Composite):可以将最小组件合并到一起

适用场景：

- 表示对象的“部分-整体”层次结构(特别是结构是递归的)
- 希望用户忽略组合对象与单个对象的不同，用户统一地使用组合结构中的所有对象。

优点：

- 定义了包含基本对象和组合对象的类层次结构
- 简化客户端代码，即客户端可以一致地使用组合对象和单个对象
- 更容易增加新类型组件

### 3.4外观模式

定义：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

角色：

- 外观(Facade):
- 子系统类(Subsystem classes)

优点：

- 减少系统相互依赖：将底层子系统类和高层代码解耦
- 提高了灵活性：
- 提高了安全性：客户端不用接触底层子系统类

### 3.5代理模式

定义：为其他对象提供一种代理以控制对这个对象的访问。

应用场景：

- 远程代理：为远程的对象提供代理
- 虚代理：根据需要创建很大的对象
- 保护代理：控制对原始对象的访问，用于对象有不同访问权限时

角色：

- 抽象实体(Subject)：
- 实体(Real Subject)：
- 代理(Proxy)：

优点：

- 远程代理：可以隐藏对象位于远程地址空间的事实。
- 虚代理：可以进行优化，例如根据要求创建对象。
- 保护代理：允许在访问一个对象时有一些附加的内务处理。

## 4.行为型模式

### 4.1责任链模式

定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

举例：一个任务发送过来，会将任务按照一条责任链进行传输，谁有权限处理，最后谁处理。

角色：

- 抽象处理者(Handler):
- 具体处理者(Concrete Handler):
- 客户端(Client):

适用场景：

- 有多个对象可以处理一个请求，哪个对象处理由运行时决定
- 在不明确接收者的情况下，向多个对象中的一个提交请求

优点：

- 降低耦合度：一个对象无需知道是其他哪一个对象处理其请求

### 4.2观察者模式

定义：定义对象间的一种一对多的依赖关系，当一个对象(发布者)的状态发生改变时，所有依赖于它的对象(订阅者)都得到通知并被自动更新。观察者模式又称“发布-订阅”模式。

角色：

- 抽象主题(Subject):
- 具体主题(Concrete Subject):发布者
- 抽象观察者(Observer):
- 具体观察者(Concrete Observer):订阅者

适用场景：

- 当一个抽象模型有两方面，其中一个方面依赖于另一个方面。将这两者封装在独立对象中以使它们可以各自独立地改变和复用。
- 当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。
- 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。

优点：

- 目标和观察者之间的抽象耦合最小
- 支持广播通信

### 4.3策略模式

定义：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。程序可以自动切换策略

角色：

- 抽象策略(Strategy):
- 具体策略(Concrete Strategy):
- 上下文(Context):

优点：

- 定义了一系列可重用的算法和行为
- 消除了一些条件语句
- 可以提供相同行为的不同实现

缺点：

- 客户必须了解不同的策略